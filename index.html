<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Gerador de Roteiro</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>

  <script>


class CapCutStyleGenerator {
    constructor(pixiContainerId, statusElementId) {
        this.pixiContainerId = pixiContainerId;
        this.statusElementId = statusElementId;
        this.app = null; this.subtitles = []; this.images = []; this.currentSubtitleIndex = 0;
        this.startTime = 0; this.isPlaying = false; this.imageContainer = null; this.mediaRecorder = null;
        this.recordedChunks = []; this.canvasWidth = 405; this.canvasHeight = 720;
        this.transitionSpeed = 0.7; this.blurIntensity = 8; this.safetyZoom = 1.25;
        this.continuousIntensity = 0.6; this.currentSprite = null; this.isTransitioning = false;
        this.continuousAnimationTime = 0; this.baseImageScale = 1; this.baseImageX = 0;
        this.baseImageY = 0; this.lastImageIndex = -1; this.currentAnimationType = null;
        this.animationPhase = 0; this.animationSpeed = 1; this.animationAmplitude = 1;
        this.isSeeking = false; this.audioElement = null;
        this.transitionTypes = ['smoothSlideLeft', 'smoothSlideRight', 'smoothSlideUp', 'smoothSlideDown', 'zoomCrossfade', 'rotateZoom', 'scaleSlide', 'blurCrossfade', 'explosiveZoomIn', 'explosiveZoomOut', 'spiralBlur', 'waveSlide', 'liquidMorph', 'shatterTransition', 'windBlur', 'orbitalSlide', 'shearSlideLeft', 'shearSlideRight', 'shearSlideUp', 'shearSlideDown'];
        this.continuousAnimations = ['gentleDrift', 'smoothFloat', 'gentleSpin', 'breathingZoom', 'orbitalDrift', 'magneticPendulum', 'pulseWave', 'elasticFloat', 'focalDrift', 'hypnoticSpin', 'liquidBreathing', 'cosmicDrift', 'heartbeat', 'windSway', 'oceanWave'];
    }

    async init() {
        try {
            this.app = new PIXI.Application({ width: this.canvasWidth, height: this.canvasHeight, backgroundColor: 0x000000, antialias: true, resolution: 2 });
            const pixiContainer = document.getElementById(this.pixiContainerId);
            if (pixiContainer) {
                pixiContainer.innerHTML = '';
                pixiContainer.appendChild(this.app.view);
            } else { return console.error(`Cont√™iner #${this.pixiContainerId} n√£o encontrado.`); }
            this.imageContainer = new PIXI.Container();
            this.app.stage.addChild(this.imageContainer);
            this.updateStatus('‚úÖ Motor de v√≠deo pronto!');
        } catch (error) { console.error('Erro na inicializa√ß√£o do PixiJS:', error); this.updateStatus('‚ùå Erro no motor de v√≠deo.'); }
    }

    updateStatus(message) { const statusEl = document.getElementById(this.statusElementId); if (statusEl) statusEl.textContent = message; }

    async loadAssets(imageDataUrls, audioBlobUrl) {
        if (!imageDataUrls || imageDataUrls.length === 0 || !audioBlobUrl) { throw new Error('Dados de imagens ou √°udio ausentes!'); }
        this.updateStatus('üñºÔ∏è Carregando imagens...');
        this.images = await this.loadImagesFromDataUrls(imageDataUrls);
        this.audioElement = new Audio(audioBlobUrl);
        await new Promise(resolve => this.audioElement.onloadedmetadata = resolve);
        this.updateStatus(`‚úÖ ${this.images.length} imagens e √°udio carregados.`);
    }

    parseSRT(srtContent) {
        const blocks = srtContent.trim().split(/\n\s*\n/);
        this.subtitles = [];
        for (let block of blocks) {
            const lines = block.trim().split('\n');
            if (lines.length < 2) continue;
            try {
                const timeRange = lines[1];
                const text = lines.slice(2).join(' ').trim();
                const [startStr, endStr] = timeRange.split(' --> ');
                const startTime = this.parseSrtTime(startStr.trim());
                const endTime = this.parseSrtTime(endStr.trim());
                this.subtitles.push({ startTime, endTime, text });
            } catch (e) { console.warn("Bloco SRT inv√°lido ignorado:", block); }
        }
        if (this.subtitles.length === 0) throw new Error('Nenhuma legenda v√°lida encontrada no conte√∫do SRT.');
    }

    async exportVideo(onFinishCallback) {
    if (!this.app || !this.audioElement || this.images.length === 0) { 
        return alert('Motor n√£o est√° pronto.'); 
    }
    
    try {
        // N√£o usar AudioContext que precisa de intera√ß√£o do usu√°rio
        const videoStream = this.app.view.captureStream(30);
        
        // Verificar se o stream de v√≠deo √© v√°lido
        if (videoStream.getVideoTracks().length === 0) {
            throw new Error('Stream de v√≠deo n√£o tem tracks');
        }
        
        // Usar apenas o v√≠deo, sem √°udio para evitar problemas de autoplay
        let mimeType = 'video/webm;codecs=vp8';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'video/webm';
            }
        }
        
        this.mediaRecorder = new MediaRecorder(videoStream, { 
            mimeType: mimeType,
            videoBitsPerSecond: 2500000
        });
        
        this.recordedChunks = [];
        
        this.mediaRecorder.ondataavailable = (event) => { 
            if (event.data.size > 0) {
                this.recordedChunks.push(event.data); 
            }
        };
        
        this.mediaRecorder.onstop = () => {
            if (this.recordedChunks.length === 0) {
                alert("Erro: nenhum dado gravado.");
                if(onFinishCallback) onFinishCallback(null);
                return;
            }
            
            const blob = new Blob(this.recordedChunks, { type: mimeType });
            
            if (blob.size === 0) { 
                alert("Erro: grava√ß√£o resultou em v√≠deo vazio."); 
                if(onFinishCallback) onFinishCallback(null); 
                return; 
            }
            
            const finalVideoUrl = URL.createObjectURL(blob);
            if (onFinishCallback) onFinishCallback(finalVideoUrl);
            
            this.pause();
        };

        this.mediaRecorder.onerror = (event) => {
            console.error('Erro no MediaRecorder:', event);
            alert('Erro durante a grava√ß√£o');
        };

        // Iniciar grava√ß√£o e anima√ß√£o simultaneamente
        this.mediaRecorder.start(100);
        this.play(); // Usa apenas a anima√ß√£o visual, sem √°udio
        this.updateStatus('üé• Gravando v√≠deo...');
        
        // Calcular dura√ß√£o baseada no √°udio, mas sem reproduzi-lo
        const totalDuration = this.audioElement.duration * 1000;
        
        setTimeout(() => { 
            if (this.mediaRecorder?.state === "recording") {
                this.mediaRecorder.stop(); 
            }
        }, totalDuration + 1000);
        
    } catch (error) {
        console.error('Erro na exporta√ß√£o:', error);
        this.updateStatus('‚ùå Erro na exporta√ß√£o: ' + error.message);
        if (onFinishCallback) onFinishCallback(null);
    }
}

    async loadImagesFromDataUrls(dataUrls) { const images = []; for (let i = 0; i < dataUrls.length; i++) { try { const texture = await PIXI.Assets.load(dataUrls[i]); images.push({ texture, name: `image_${i}.jpg` }); this.updateStatus(`‚úÖ Imagem ${i + 1}/${dataUrls.length}`); } catch (error) { throw new Error(`Erro ao carregar imagem ${i + 1}: ${error.message}`); } } return images; }
    parseSrtTime(timeStr) { const [time, ms] = timeStr.split(','); const [h, m, s] = time.split(':').map(Number); return h * 3600 + m * 60 + s + (parseInt(ms) / 1000); }
    play() { this.imageContainer.removeChildren(); this.currentSprite = null; this.lastImageIndex = -1; this.isSeeking = false; this.isPlaying = true; this.startTime = Date.now(); this.currentSubtitleIndex = 0; this.animate(); this.animateContinuous(); }
    pause() { this.isPlaying = false; }
    animate() { if (!this.isPlaying) return; const currentTime = (Date.now() - this.startTime) / 1000; if (this.currentSubtitleIndex < this.subtitles.length) { const nextSub = this.subtitles[this.currentSubtitleIndex]; if (currentTime >= nextSub.startTime && !this.isSeeking) { this.isSeeking = true; const imageIndex = Math.min(this.currentSubtitleIndex, this.images.length - 1); this.showImage(imageIndex).then(() => { this.currentSubtitleIndex++; this.isSeeking = false; }); } } else { const lastSub = this.subtitles[this.subtitles.length - 1]; if (lastSub && currentTime > lastSub.endTime + 0.5) { this.pause(); return; } } requestAnimationFrame(() => this.animate()); }
    async showImage(imageIndex) { const nextImage = this.images[imageIndex]; if (!nextImage?.texture) return; if (this.lastImageIndex !== imageIndex) { this.setRandomAnimationForCurrentImage(); if (this.currentSprite) { const currentImage = this.images[Math.max(0, this.lastImageIndex)]; const transitionType = this.transitionTypes[Math.floor(Math.random() * this.transitionTypes.length)]; await this.performTransition(currentImage, nextImage, transitionType); } else { const data = this.createSafeSprite(nextImage.texture); this.imageContainer.addChild(data.sprite); this.currentSprite = data.sprite; this.baseImageScale = data.baseScale; this.baseImageX = data.baseX; this.baseImageY = data.baseY; this.applyCurrentAnimation(); } this.lastImageIndex = imageIndex; } }
    animateContinuous() { if (!this.isPlaying) return; if (this.currentSprite && !this.isTransitioning && this.currentAnimationType) { this.continuousAnimationTime += 0.016 * this.animationSpeed; this.applyCurrentAnimation(); } requestAnimationFrame(() => this.animateContinuous()); }
    applyCurrentAnimation() { if (!this.currentAnimationType || !this.currentSprite) return; const values = this.calculateAnimationValues(this.currentAnimationType); this.currentSprite.scale.set(values.scale); this.currentSprite.x = values.x; this.currentSprite.y = values.y; this.currentSprite.rotation = values.rotation; this.currentSprite.skew.set(values.skew.x, values.skew.y); }
    setRandomAnimationForCurrentImage() { const oldAnimation = this.currentAnimationType; let newAnimation = oldAnimation; if (this.continuousAnimations.length > 1) { while (newAnimation === oldAnimation) { newAnimation = this.continuousAnimations[Math.floor(Math.random() * this.continuousAnimations.length)]; } } else { newAnimation = this.continuousAnimations[0]; } this.currentAnimationType = newAnimation; this.continuousAnimationTime = 0; this.animationPhase = Math.random() * Math.PI * 2; this.animationSpeed = 0.8 + Math.random() * 0.4; this.animationAmplitude = 0.7 + Math.random() * 0.6; }
    createSafeSprite(texture, extraZoom = 1) { const sprite = new PIXI.Sprite(texture); const scale = Math.max(this.canvasWidth / texture.width, this.canvasHeight / texture.height) * this.safetyZoom * extraZoom; sprite.scale.set(scale); sprite.anchor.set(0.5); sprite.x = this.canvasWidth / 2; sprite.y = this.canvasHeight / 2; return { sprite, baseScale: scale, baseX: sprite.x, baseY: sprite.y }; }
    async performTransition(fromImage, toImage, transitionType) { return new Promise((resolve) => { this.isTransitioning = true; this.imageContainer.removeChildren(); const fromData = this.createSafeSprite(fromImage.texture); const toData = this.createSafeSprite(toImage.texture); this.imageContainer.addChild(fromData.sprite); this.imageContainer.addChild(toData.sprite); this.setupTransitionInitialState(fromData, toData, transitionType); const startTime = Date.now(); const duration = this.transitionSpeed * 1000; const animate = () => { const elapsed = Date.now() - startTime; let progress = Math.min(elapsed / duration, 1); progress = this.getTransitionEasing(transitionType, progress); this.applyTransitionAnimation(fromData, toData, transitionType, progress); if (elapsed < duration) { requestAnimationFrame(animate); } else { this.imageContainer.removeChild(fromData.sprite); this.currentSprite = toData.sprite; this.baseImageScale = toData.baseScale; this.baseImageX = toData.baseX; this.baseImageY = toData.baseY; this.applyCurrentAnimation(); this.isTransitioning = false; resolve(); } }; animate(); }); }
    applyTransitionAnimation(fromData, toData, transitionType, progress) { const { sprite: fromSprite, baseX: fromX, baseY: fromY, baseScale: fromScale } = fromData; const { sprite: toSprite, baseX: toX, baseY: toY, baseScale: toScale } = toData; const dynamicZoom = 1 + 0.8 * Math.sin(progress * Math.PI); switch (transitionType) { case 'smoothSlideLeft': fromSprite.x = fromX - (this.canvasWidth * progress); toSprite.x = (toX + this.canvasWidth) - (this.canvasWidth * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideRight': fromSprite.x = fromX + (this.canvasWidth * progress); toSprite.x = (toX - this.canvasWidth) + (this.canvasWidth * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideUp': fromSprite.y = fromY - (this.canvasHeight * progress); toSprite.y = (toY + this.canvasHeight) - (this.canvasHeight * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'smoothSlideDown': fromSprite.y = fromY + (this.canvasHeight * progress); toSprite.y = (toY - this.canvasHeight) + (this.canvasHeight * progress); fromSprite.alpha = 1 - progress * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'zoomCrossfade': fromSprite.scale.set(fromScale * (1 + progress * 0.3) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 0.8) + (toScale * 0.2 * progress)) * dynamicZoom); toSprite.alpha = progress; break; case 'rotateZoom': fromSprite.rotation = progress * Math.PI * 0.2; fromSprite.scale.set(fromScale * (1 + progress * 0.2) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 0.7) + (toScale * 0.3 * progress)) * dynamicZoom); toSprite.rotation = (1 - progress) * Math.PI * 0.5; toSprite.alpha = progress; break; case 'scaleSlide': fromSprite.x = fromX - (this.canvasWidth * progress * 0.3); fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.x = (toX + this.canvasWidth * 0.5) - (this.canvasWidth * 0.5 * progress); toSprite.scale.set(((toScale * 0.6) + (toScale * 0.4 * progress)) * dynamicZoom); toSprite.alpha = progress; break; case 'blurCrossfade': fromSprite.scale.set(fromScale * (1 + Math.sin(progress * Math.PI) * this.blurIntensity * 0.1) * dynamicZoom); fromSprite.alpha = 1 - progress; toSprite.scale.set(((toScale * 1.1) - (toScale * 0.1 * progress)) * (1 + Math.sin(progress * Math.PI) * this.blurIntensity * 0.05) * dynamicZoom); toSprite.alpha = progress; break; case 'explosiveZoomIn': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 + progress * 0.5) * dynamicZoom); fromSprite.rotation = progress * Math.PI * 0.5; toSprite.scale.set(((toScale * 0.1) + (toScale * 0.9 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.rotation = (1 - progress) * Math.PI * 2; break; case 'explosiveZoomOut': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); const targetScale = (toScale * 3 * (1 - progress)) + (toScale * progress); toSprite.scale.set(targetScale * dynamicZoom); toSprite.rotation = -2 * Math.PI * (1 - progress); toSprite.alpha = progress; break; case 'spiralBlur': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI * 2; fromSprite.scale.set(fromScale * (1 - progress * 0.3) * dynamicZoom); toSprite.scale.set(((toScale * 0.3) + (toScale * 0.7 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.x = (toX + this.canvasWidth) - (this.canvasWidth * progress); toSprite.rotation = (1 - progress) * Math.PI * 4; break; case 'waveSlide': const waveOffset = Math.sin(progress * Math.PI * 6) * 20 * (1 - progress); fromSprite.x = fromX + (this.canvasWidth * progress); fromSprite.y = fromY + waveOffset; fromSprite.alpha = 1 - progress; fromSprite.skew.x = progress * 0.3; toSprite.x = (toX - this.canvasWidth) + (this.canvasWidth * progress); toSprite.y = toY - waveOffset; toSprite.alpha = progress; toSprite.skew.x = (1 - progress) * 0.3; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'liquidMorph': fromSprite.alpha = 1 - progress; fromSprite.scale.set(fromScale * (1 + progress * 0.3) * dynamicZoom); fromSprite.skew.x = Math.sin(progress * Math.PI * 2) * 0.3; toSprite.scale.set(((toScale * 2) - toScale * progress) * dynamicZoom); toSprite.alpha = 0.3 + (progress * 0.7); toSprite.skew.y = Math.cos(progress * Math.PI * 3) * 0.2; break; case 'shatterTransition': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI * 0.5; fromSprite.scale.set(fromScale * (1 - progress * 0.2) * dynamicZoom); toSprite.scale.set(((toScale * 0.5) + (toScale * 0.5 * progress)) * dynamicZoom); toSprite.alpha = progress; toSprite.x = toSprite.x + (toX - toSprite.x) * progress; toSprite.y = toSprite.y + (toY - toSprite.y) * progress; toSprite.rotation = toSprite.rotation * (1 - progress); break; case 'windBlur': const windIntensity = Math.sin(progress * Math.PI) * 1.5; fromSprite.alpha = 1 - progress; fromSprite.skew.x = windIntensity * 0.1; fromSprite.x = fromX + windIntensity * 20; fromSprite.y = fromY + Math.sin(progress * Math.PI * 4) * 10; toSprite.x = (toX + this.canvasWidth * 0.8) - (this.canvasWidth * 0.8 * progress); toSprite.y = (toY - this.canvasHeight * 0.3) + (this.canvasHeight * 0.3 * progress); toSprite.alpha = progress; toSprite.skew.x = -(1 - progress) * 0.2; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'orbitalSlide': fromSprite.alpha = 1 - progress; fromSprite.rotation = progress * Math.PI; const startAngle = Math.atan2(toSprite.y - toY, toSprite.x - toX); const currentAngle = startAngle * (1 - progress); const currentRadius = this.canvasWidth * 1.2 * (1 - progress); toSprite.x = toX + Math.cos(currentAngle) * currentRadius; toSprite.y = toY + Math.sin(currentAngle) * currentRadius; toSprite.alpha = progress; toSprite.rotation = currentAngle + (2 * Math.PI * progress); fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideLeft': fromSprite.skew.x = -progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.x = (1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideRight': fromSprite.skew.x = progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.x = -(1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideUp': fromSprite.skew.y = -progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.y = (1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; case 'shearSlideDown': fromSprite.skew.y = progress * 0.7; fromSprite.alpha = 1 - progress; toSprite.skew.y = -(1 - progress) * 0.7; toSprite.alpha = progress; fromSprite.scale.set(fromScale * dynamicZoom); toSprite.scale.set(toScale * dynamicZoom); break; default: fromSprite.alpha = 1 - progress; toSprite.alpha = progress; break; } }
    calculateAnimationValues(animationType) { const intensity = this.continuousIntensity * this.animationAmplitude; const time = this.continuousAnimationTime; let scale = this.baseImageScale, x = this.baseImageX, y = this.baseImageY, rotation = 0; let skew = { x: 0, y: 0 }; switch (animationType) { case 'focalDrift': const driftSpeedX = 0.3, driftSpeedY = 0.5, focusSpeed = 0.2; x = this.baseImageX + Math.sin(time * driftSpeedX + this.animationPhase) * 12 * intensity; y = this.baseImageY + Math.cos(time * driftSpeedY + this.animationPhase * 1.2) * 8 * intensity; scale = this.baseImageScale * (1 + Math.sin(time * focusSpeed + this.animationPhase * 1.5) * 0.05 * intensity); break; case 'gentleDrift': x = this.baseImageX + Math.cos(time * 0.6 + this.animationPhase) * 8 * intensity; y = this.baseImageY + Math.sin(time * 0.8 + this.animationPhase) * 6 * intensity; break; case 'smoothFloat': y = this.baseImageY + Math.sin(time * 1.1 + this.animationPhase) * 10 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.5) * 0.025 * intensity); break; case 'gentleSpin': rotation = Math.sin(time * 0.5 + this.animationPhase) * 0.08 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.8) * 0.03 * intensity); break; case 'breathingZoom': scale = this.baseImageScale * (1 + Math.sin(time * 1.5 + this.animationPhase) * 0.06 * intensity); break; case 'orbitalDrift': const orbitRadius = 15 * intensity; x = this.baseImageX + Math.cos(time * 0.8 + this.animationPhase) * orbitRadius; y = this.baseImageY + Math.sin(time * 1.1 + this.animationPhase) * orbitRadius * 0.7; scale = this.baseImageScale * (1 + Math.sin(time * 2) * 0.03 * intensity); break; case 'magneticPendulum': rotation = Math.sin(time * 1.2 + this.animationPhase) * 0.12 * intensity; x = this.baseImageX + Math.cos(time * 0.6) * 10 * intensity; break; case 'pulseWave': const pulseIntensity = Math.sin(time * 3 + this.animationPhase); scale = this.baseImageScale * (1 + pulseIntensity * 0.08 * intensity); rotation = pulseIntensity * 0.05 * intensity; break; case 'elasticFloat': y = this.baseImageY + Math.sin(time * 1.8 + this.animationPhase) * 20 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 2.5) * 0.04 * intensity); skew.x = Math.sin(time * 1.3) * 0.1 * intensity; break; case 'hypnoticSpin': rotation = Math.sin(time * 0.8 + this.animationPhase) * 0.15 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 2.2) * 0.05 * intensity); break; case 'liquidBreathing': scale = this.baseImageScale * (1 + Math.sin(time * 1.1 + this.animationPhase) * 0.07 * intensity); skew.x = Math.sin(time * 1.4) * 0.08 * intensity; skew.y = Math.cos(time * 1.7) * 0.05 * intensity; break; case 'cosmicDrift': const cosmicRadius = 25 * intensity, cosmicAngle = time * 0.3 + this.animationPhase; x = this.baseImageX + Math.cos(cosmicAngle) * cosmicRadius; y = this.baseImageY + Math.sin(cosmicAngle * 1.4) * cosmicRadius * 0.6; scale = this.baseImageScale * (1 + Math.sin(time * 1.6) * 0.04 * intensity); rotation = Math.sin(time * 0.7) * 0.08 * intensity; break; case 'heartbeat': const heartBeat = Math.max(0, Math.sin(time * 4 + this.animationPhase)); scale = this.baseImageScale * (1 + heartBeat * 0.12 * intensity); break; case 'windSway': x = this.baseImageX + Math.sin(time * 0.9 + this.animationPhase) * 18 * intensity; rotation = Math.sin(time * 1.1) * 0.1 * intensity; scale = this.baseImageScale * (1 + Math.cos(time * 1.5) * 0.03 * intensity); break; case 'oceanWave': x = this.baseImageX + Math.sin(time * 1.2 + this.animationPhase) * 12 * intensity; y = this.baseImageY + Math.cos(time * 0.8 + this.animationPhase) * 8 * intensity; scale = this.baseImageScale * (1 + Math.sin(time * 2.1) * 0.05 * intensity); skew.x = Math.sin(time * 1.4) * 0.06 * intensity; break; } return { scale, x, y, rotation, skew }; }
    setupTransitionInitialState(fromData, toData, transitionType) { const { sprite: fromSprite } = fromData; const { sprite: toSprite } = toData; fromSprite.alpha = 1; fromSprite.rotation = 0; fromSprite.skew.set(0); fromSprite.scale.set(fromData.baseScale); fromSprite.x = fromData.baseX; fromSprite.y = fromData.baseY; toSprite.alpha = 0; toSprite.rotation = 0; toSprite.skew.set(0); toSprite.scale.set(toData.baseScale); switch (transitionType) { case 'smoothSlideLeft': toSprite.x = toData.baseX + this.canvasWidth; toSprite.y = toData.baseY; break; case 'smoothSlideRight': toSprite.x = toData.baseX - this.canvasWidth; toSprite.y = toData.baseY; break; case 'smoothSlideUp': toSprite.x = toData.baseX; toSprite.y = toData.baseY + this.canvasHeight; break; case 'smoothSlideDown': toSprite.x = toData.baseX; toSprite.y = toData.baseY - this.canvasHeight; break; case 'zoomCrossfade': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.8); break; case 'rotateZoom': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.7); toSprite.rotation = Math.PI * 0.5; break; case 'scaleSlide': toSprite.x = toData.baseX + this.canvasWidth * 0.5; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 0.6); break; case 'blurCrossfade': toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.scale.set(toData.baseScale * 1.1); break; case 'explosiveZoomIn': toSprite.scale.set(toData.baseScale * 0.1); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.rotation = Math.PI * 2; break; case 'explosiveZoomOut': toSprite.scale.set(toData.baseScale * 3); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.rotation = -Math.PI * 2; break; case 'spiralBlur': toSprite.scale.set(toData.baseScale * 0.3); toSprite.x = toData.baseX + this.canvasWidth; toSprite.y = toData.baseY; toSprite.rotation = Math.PI * 4; break; case 'waveSlide': toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX - this.canvasWidth; toSprite.y = toData.baseY; break; case 'liquidMorph': toSprite.scale.set(toData.baseScale * 2); toSprite.x = toData.baseX; toSprite.y = toData.baseY; toSprite.alpha = 0.3; break; case 'shatterTransition': toSprite.scale.set(toData.baseScale * 0.5); toSprite.x = toData.baseX + (Math.random() - 0.5) * this.canvasWidth; toSprite.y = toData.baseY + (Math.random() - 0.5) * this.canvasHeight; toSprite.rotation = Math.random() * Math.PI; break; case 'windBlur': toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX + this.canvasWidth * 0.8; toSprite.y = toData.baseY - this.canvasHeight * 0.3; break; case 'orbitalSlide': const angle = Math.random() * Math.PI * 2, radius = this.canvasWidth * 1.2; toSprite.scale.set(toData.baseScale); toSprite.x = toData.baseX + Math.cos(angle) * radius; toSprite.y = toData.baseY + Math.sin(angle) * radius; toSprite.rotation = angle; break; default: toSprite.x = toData.baseX; toSprite.y = toData.baseY; break; } }
    easeOutQuart(t) { return 1 - Math.pow(1 - t, 4); }
    easeOutExpo(t) { return t === 1 ? 1 : 1 - Math.pow(2, -10 * t); }
    easeInOutBack(t) { const c1 = 1.70158, c2 = c1 * 1.525; return t < 0.5 ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2; }
    easeOutBounce(t) { const n1 = 7.5625, d1 = 2.75; if (t < 1 / d1) return n1 * t * t; else if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75; else if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375; else return n1 * (t -= 2.625 / d1) * t + 0.984375; }
    getTransitionEasing(type, t) { switch (type) { case 'explosiveZoomIn': case 'explosiveZoomOut': return this.easeOutExpo(t); case 'spiralBlur': case 'liquidMorph': return this.easeInOutBack(t); case 'shatterTransition': return this.easeOutBounce(t); default: return this.easeOutQuart(t); } }
}


/**
 * WordSubtitleAnimator.js
 * Sistema de legendas animadas palavra por palavra estilo TikTok
 * Integra-se perfeitamente com o CapCutStyleGenerator existente
 */

 class WordSubtitleAnimator {
    constructor() {
        this.app = null;
        this.container = null;
        this.wordElements = [];
        this.timeline = [];
        this.currentWordIndex = 0;
        this.isInitialized = false;
        
        // Configura√ß√µes visuais estilo TikTok
        this.config = {
            fontSize: 48,
            fontFamily: 'Arial Black, sans-serif',
            fontWeight: 900,
            fillColor: 0xFFFFFF,
            strokeColor: 0x000000,
            strokeThickness: 4,
            dropShadowColor: 0x000000,
            dropShadowAlpha: 0.8,
            dropShadowDistance: 3,
            dropShadowBlur: 2,
            
            // Anima√ß√µes
            popScale: 1.2,
            popDuration: 0.15,
            fadeDuration: 0.1,
            
            // Posicionamento
            maxWidth: 380,
            lineHeight: 1.2,
            bottomMargin: 120,
            wordsPerLine: 4
        };
    }

    /**
     * Inicializa o sistema de legendas
     * @param {CapCutStyleGenerator} renderer - Inst√¢ncia do renderizador principal
     */
    init(renderer) {
        if (!renderer || !renderer.app) {
            throw new Error('Renderer inv√°lido ou n√£o inicializado');
        }
        
        this.app = renderer.app;
        this.setupContainer();
        this.isInitialized = true;
        
        console.log('‚úÖ WordSubtitleAnimator inicializado');
    }

    /**
     * Configura o container das legendas
     */
    setupContainer() {
        // Remove container anterior se existir
        if (this.container) {
            this.app.stage.removeChild(this.container);
        }
        
        this.container = new PIXI.Container();
        this.container.name = 'subtitles-container';
        
        // Posiciona no centro-inferior da tela
        this.container.x = this.app.screen.width / 2;
        this.container.y = this.app.screen.height - this.config.bottomMargin;
        
        // Adiciona ao stage no topo (√∫ltima camada)
        this.app.stage.addChild(this.container);
    }

    /**
     * Define os dados de timeline das palavras
     * @param {Array|Object} data - Segmentos do Whisper ou dados completos da transcri√ß√£o
     */
    setTimeline(data) {
        console.log('üîç Recebendo dados para timeline:', data);
        
        this.timeline = [];
        
        // Se receber o objeto completo da transcri√ß√£o
        if (data.words && Array.isArray(data.words)) {
            console.log('üìù Usando array de palavras direto');
            data.words.forEach(wordData => {
                this.timeline.push({
                    word: wordData.word.trim(),
                    start: wordData.start,
                    end: wordData.end,
                    duration: wordData.end - wordData.start
                });
            });
        }
        // Se receber array de segmentos
        else if (Array.isArray(data)) {
            console.log('üìù Processando segmentos');
            data.forEach(segment => {
                if (segment.words) {
                    segment.words.forEach(wordData => {
                        this.timeline.push({
                            word: wordData.word.trim(),
                            start: wordData.start,
                            end: wordData.end,
                            duration: wordData.end - wordData.start
                        });
                    });
                }
            });
        }
        
        console.log(`üìù Timeline carregada: ${this.timeline.length} palavras`);
        console.log('üìù Primeiras 3 palavras:', this.timeline.slice(0, 3));
        
        if (this.timeline.length > 0) {
            this.createWordElements();
        } else {
            console.warn('‚ö†Ô∏è Nenhuma palavra encontrada na timeline');
        }
    }

    /**
     * Cria os elementos visuais para todas as palavras
     */
    createWordElements() {
        // Limpa elementos anteriores
        this.wordElements.forEach(element => {
            if (element.parent) {
                element.parent.removeChild(element);
            }
        });
        this.wordElements = [];

        // Cria uma palavra por vez (estilo TikTok cl√°ssico)
        this.timeline.forEach((wordData, index) => {
            const textElement = this.createWordElement(wordData, index);
            
            // Posiciona no centro da tela
            textElement.x = 0;
            textElement.y = 0;
            
            // Inicialmente invis√≠vel
            textElement.alpha = 0;
            textElement.scale.set(0.8);
            
            this.container.addChild(textElement);
            this.wordElements.push(textElement);
        });
        
        console.log(`üìù Criados ${this.wordElements.length} elementos de palavra (modo TikTok)`);
    }

    /**
     * Cria elemento visual para uma palavra
     */
    createWordElement(wordData, index) {
        // Cria texto com estilo TikTok
        const textStyle = new PIXI.TextStyle({
            fontFamily: this.config.fontFamily,
            fontSize: this.config.fontSize,
            fontWeight: this.config.fontWeight,
            fill: this.config.fillColor,
            stroke: this.config.strokeColor,
            strokeThickness: this.config.strokeThickness,
            dropShadow: true,
            dropShadowColor: this.config.dropShadowColor,
            dropShadowAlpha: this.config.dropShadowAlpha,
            dropShadowDistance: this.config.dropShadowDistance,
            dropShadowBlur: this.config.dropShadowBlur,
            wordWrap: false
        });

        const textElement = new PIXI.Text(wordData.word, textStyle);
        textElement.anchor.set(0.5, 0.5);
        
        // Configura√ß√µes iniciais
        textElement.alpha = 0; // Completamente invis√≠vel inicialmente
        textElement.scale.set(0.8);
        
        // Guarda dados da palavra no elemento
        textElement.wordData = wordData;
        textElement.wordIndex = index;
        textElement.isActive = false;
        
        return textElement;
    }

/**
 * Inicia a anima√ß√£o sincronizada com timing real (sem reproduzir √°udio)
 * @param {HTMLAudioElement} audioElement - Elemento de √°udio (apenas para dura√ß√£o)
 */
startAnimation(audioElement) {
    if (!this.isInitialized) {
        console.warn('‚ö†Ô∏è WordSubtitleAnimator n√£o foi inicializado');
        return;
    }
    
    console.log('üé¨ Iniciando anima√ß√£o de legendas (timing real)');
    
    // Reset
    this.currentWordIndex = 0;
    this.resetAllWords();
    
    this.container.visible = true;
    
    // Usa o timing real do √°udio sem reproduzi-lo
    this.syncWithRealTiming(audioElement.duration);
}

/**
 * Sincroniza com o tempo real baseado na dura√ß√£o do √°udio
 */
syncWithRealTiming(totalDuration) {
    console.log('üîÑ Iniciando sincroniza√ß√£o com timing real');
    
    const startTime = Date.now();
    let animationId;
    
    const updateSubtitles = () => {
        const elapsed = (Date.now() - startTime) / 1000; // Tempo real em segundos
        
        if (elapsed >= totalDuration) {
            console.log('‚èπÔ∏è Anima√ß√£o finalizada');
            if (animationId) cancelAnimationFrame(animationId);
            this.resetAllWords();
            return;
        }
        
        // Usa o tempo real que corresponde ao timing do √°udio original
        this.updateWordStates(elapsed);
        animationId = requestAnimationFrame(updateSubtitles);
    };
    
    updateSubtitles();
    
    return () => {
        if (animationId) cancelAnimationFrame(animationId);
    };
}

    /**
     * Atualiza estado das palavras baseado no tempo atual
     */
    updateWordStates(currentTime) {
        let currentActiveElement = null;
        
        // Encontra qual palavra deve estar ativa neste momento
        this.wordElements.forEach((element) => {
            const wordData = element.wordData;
            const isInTimeRange = currentTime >= wordData.start && currentTime <= wordData.end;
            
            if (isInTimeRange) {
                currentActiveElement = element;
            }
        });
        
        // Se tem uma palavra que deveria estar ativa
        if (currentActiveElement) {
            // Se essa palavra ainda n√£o est√° ativa
            if (!currentActiveElement.isActive) {
                // PRIMEIRO: Desativa TODAS as outras palavras IMEDIATAMENTE
                this.wordElements.forEach((element) => {
                    if (element !== currentActiveElement && element.isActive) {
                        element.isActive = false;
                        element.alpha = 0;
                        element.visible = false;
                    }
                });
                
                // SEGUNDO: Ativa APENAS a palavra atual
                console.log(`‚ú® Ativando palavra: "${currentActiveElement.wordData.word}"`);
                this.activateWord(currentActiveElement);
            }
        } else {
            // Se n√£o tem palavra ativa, desativa todas
            this.wordElements.forEach((element) => {
                if (element.isActive) {
                    element.isActive = false;
                    element.alpha = 0;
                    element.visible = false;
                }
            });
        }
    }

    /**
     * Anima ativa√ß√£o de uma palavra
     */
    activateWord(element) {
        element.isActive = true;
        element.visible = true;
        
        // Anima√ß√£o de entrada
        const startTime = Date.now();
        const duration = 300;
        
        const animate = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            if (progress < 1) {
                const easeBack = 1 - Math.pow(1 - progress, 3) * (1 - Math.sin(progress * Math.PI * 2) * 0.2);
                element.scale.set(0.8 + easeBack * 0.4);
                element.alpha = progress;
                requestAnimationFrame(animate);
            } else {
                element.scale.set(1.1);
                element.alpha = 1;
            }
        };
        
        animate();
    }

    /**
     * Anima desativa√ß√£o de uma palavra - Sa√≠da INSTANT√ÇNEA
     */
    deactivateWord(element) {
        element.isActive = false;
        
        // Cancela anima√ß√£o anterior se existir
        if (element.currentTween) {
            element.currentTween.destroy();
            element.currentTween = null;
        }
        
        // Remove IMEDIATAMENTE - sem anima√ß√£o
        element.alpha = 0;
        element.scale.set(0.8);
        element.visible = false; // For√ßa invisibilidade total
    }

    /**
     * Reseta todas as palavras para estado inicial
     */
    resetAllWords() {
        this.wordElements.forEach(element => {
            element.alpha = 0; // Todas invis√≠veis inicialmente
            element.scale.set(0.8);
            element.isActive = false;
            
            // Cancela qualquer anima√ß√£o em andamento
            if (element.currentTween) {
                element.currentTween.destroy();
                element.currentTween = null;
            }
        });
    }

    /**
     * Atualiza configura√ß√µes visuais
     */
    updateConfig(newConfig) {
        Object.assign(this.config, newConfig);
        if (this.isInitialized) {
            this.createWordElements();
        }
    }

    /**
     * Remove o sistema de legendas
     */
    destroy() {
        if (this.container && this.container.parent) {
            this.container.parent.removeChild(this.container);
        }
        
        this.wordElements = [];
        this.timeline = [];
        this.isInitialized = false;
        
        console.log('üóëÔ∏è WordSubtitleAnimator removido');
    }
}

// Exporta para uso global
window.WordSubtitleAnimator = WordSubtitleAnimator;

</script>


</head>
<body>
  <h1>Gerador de Roteiro</h1>

  <pre id="roteiro" style="white-space: pre-wrap; background: #f0f0f0; padding: 10px; border-radius: 8px;"></pre>

  <div id="pixi-container" style="width: 405px; height: 720px; margin: auto; background: #000;"></div>

  <div id="download-section" style="display: none; text-align: center; margin-top: 20px;">
    <button id="download-btn" style="padding: 15px 30px; font-size: 16px; background: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer;">
        üì• Baixar V√≠deo
    </button>
</div>

  <script>

    const THEME = window.THEME || "Curiosidades sobre o MAR";
    const GEMINI_API_KEY = window.GEMINI_API_KEY;
    const GROQ_API_KEY = window.GROQ_API_KEY;

    const GEMINI_TEXT_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${GEMINI_API_KEY}`;
    const GEMINI_AUDIO_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_API_KEY}`;
    const GEMINI_IMAGE_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-preview-image-generation:generateContent?key=${GEMINI_API_KEY}`;


    async function callGeminiApi(url, payload) {
        const response = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload)
        });
        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(`Erro na API Gemini: ${errorBody.error?.message || response.statusText}`);
        }
        return response.json();
    }

    async function gerarRoteiro() {
        const status = document.getElementById("status");
        const roteiroBox = document.getElementById("roteiro");

        try {
            
            const scriptPrompt = `Crie um roteiro de narra√ß√£o curto e envolvente para um v√≠deo vertical sobre o tema: "${THEME}". O texto deve ser fluido e natural, dividido em 3 par√°grafos curtos. Responda apenas com o texto do roteiro.`;
            
            const scriptPayload = {
                contents: [{ parts: [{ text: scriptPrompt }] }],
                generationConfig: { temperature: 0.7 }
            };

            const scriptResult = await callGeminiApi(GEMINI_TEXT_API_URL, scriptPayload);

            const scriptPromptRevise = `Verifique o texto se existe qualquer orienta√ß√£o de como vai ser o video como (M√∫sica...), (Cena...), (Narrador...) ou instru√ß√µes, caso exista remova qualquer instru√ß√£o e me traga apenas o roteiro limpo, segue o roteiro a seguir, tamb√©m n√£o quero informa√ß√µes sua duzendo que trouxe o roteiro quero apenas o texto do roteiro n√£o seja teimoso apenas o texto do roteiro: "${scriptResult.candidates[0].content.parts[0].text.trim()}".`;

            const scriptRevisePayload = {
                contents: [{ parts: [{ text: scriptPromptRevise }] }],
                generationConfig: { temperature: 0.7 }
            };

            const reviseScript = await callGeminiApi(GEMINI_TEXT_API_URL, scriptRevisePayload);

            const scriptText = reviseScript.candidates[0].content.parts[0].text.trim();
            
            const audioBlob = await generateAudio(scriptText);

            const transcriptionResult = await transcribeAudio(audioBlob);

            const timedChunks = groupTranscriptionIntoTimedChunks(transcriptionResult.segments);

            const imageDataUrls = await generateImagesForTimedChunks(timedChunks, timedChunks.length);


            const renderer = new CapCutStyleGenerator('pixi-container', 'generation-status');
            await renderer.init();

            const audioUrl = URL.createObjectURL(audioBlob);
            await renderer.loadAssets(imageDataUrls, audioUrl);

            const srtContent = timedChunks.map((chunk, i) => {
                return `${i + 1}\n${formatSrtTime(chunk.start)} --> ${formatSrtTime(chunk.end)}\n${chunk.text}`;
            }).join('\n\n');
            
            renderer.parseSRT(srtContent);

            await iniciarAnimadorDeLegendas(renderer, transcriptionResult);
            
// Na parte onde voc√™ chama o exportVideo, substitua por:
await renderer.exportVideo(async (finalVideoUrl) => {
    if(finalVideoUrl) {
        // Mostrar se√ß√£o de download
        const downloadSection = document.getElementById('download-section');
        const downloadBtn = document.getElementById('download-btn');
        
        downloadSection.style.display = 'block';
        
        // Se quiser um v√≠deo com √°udio, combine os arquivos
        downloadBtn.onclick = async () => {
            try {
                // Op√ß√£o 1: Download apenas do v√≠deo (sem √°udio)
                const a = document.createElement('a');
                a.href = finalVideoUrl;
                a.download = `video_${THEME.replace(/\s+/g, '_')}_${Date.now()}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Op√ß√£o 2: Download separado do √°udio
                const audioUrl = URL.createObjectURL(audioBlob);
                const aAudio = document.createElement('a');
                aAudio.href = audioUrl;
                aAudio.download = `audio_${THEME.replace(/\s+/g, '_')}_${Date.now()}.wav`;
                document.body.appendChild(aAudio);
                aAudio.click();
                document.body.removeChild(aAudio);
                
            } catch (error) {
                console.error('Erro no download:', error);
            }
        };
        
        console.log('V√≠deo pronto para download:', finalVideoUrl);
    } else {
        alert("Falha ao gerar o v√≠deo final.");
    }
});

        } catch (error) {
            console.log(error)
        }
    }


    async function generateAudio(text) {    
    // Gerar √°udio
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: `Diga de forma natural e com pausas: ${text}` }] }],
                generationConfig: {
                    responseModalities: ['AUDIO'],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" }
                        }
                    }
                },
                model: 'gemini-2.5-flash-preview-tts'
            })
        });

        if (!response.ok) throw new Error(`Erro na API: ${response.statusText}`);
        
        const result = await response.json();
        const audioBase64 = result.candidates[0].content.parts[0].inlineData.data;
        
        // Converter para WAV
        const pcmData = new Int16Array(Uint8Array.from(atob(audioBase64), c => c.charCodeAt(0)).buffer);
        const buffer = new ArrayBuffer(44 + pcmData.length * 2);
        const view = new DataView(buffer);
        
        // Cabe√ßalho WAV
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + pcmData.length * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, 24000, true);
        view.setUint32(28, 48000, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, pcmData.length * 2, true);
        
        for (let i = 0; i < pcmData.length; i++) {
            view.setInt16(44 + i * 2, pcmData[i], true);
        }
        
        return new Blob([view], { type: 'audio/wav' });
    }


    async function transcribeAudio(audioBlob) {
        if (!GROQ_API_KEY) {
            throw new Error("Chave API Groq n√£o configurada.");
        }

        const formData = new FormData();
        formData.append("file", audioBlob, "audio.wav");
        formData.append("model", "whisper-large-v3");
        formData.append("response_format", "verbose_json");
        formData.append("timestamp_granularities[]", "word");
        formData.append("timestamp_granularities[]", "segment");

        const response = await fetch("https://api.groq.com/openai/v1/audio/transcriptions", {
            method: "POST",
            headers: {
                'Authorization': `Bearer ${GROQ_API_KEY}`
            },
            body: formData
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(`Erro na API Groq: ${error.error.message}`);
        }

        return response.json();
    }

    
    function groupTranscriptionIntoTimedChunks(segments, maxWordsPerChunk = 25) {
        if (!segments || segments.length === 0) return [];
        
        const chunks = [];
        let currentChunkText = "";
        let chunkStartTime = segments[0].start;

        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const potentialText = currentChunkText ? `${currentChunkText} ${segment.text}` : segment.text;

            if (potentialText.split(' ').length > maxWordsPerChunk && currentChunkText) {
                chunks.push({
                    text: currentChunkText,
                    start: chunkStartTime,
                    end: segments[i - 1].end
                });
                currentChunkText = segment.text;
                chunkStartTime = segment.start;
            } else {
                currentChunkText = potentialText;
            }
        }

        if (currentChunkText) {
            chunks.push({
                text: currentChunkText,
                start: chunkStartTime,
                end: segments[segments.length - 1].end
            });
        }
        return chunks;
    }


    async function generateImagesForTimedChunks(timedChunks, statusElement, total) {
        const imageUrls = [];
        for (let i = 0; i < timedChunks.length; i++) {
            const chunk = timedChunks[i];

            const promptForImage = `Para a frase: "${chunk.text}", crie um prompt de imagem conciso em ingl√™s para um gerador de IA. O prompt deve ser descritivo e cinematogr√°fico. Responda apenas com o prompt.`;
            const promptPayload = { contents: [{ parts: [{ text: promptForImage }] }], generationConfig: { temperature: 0.7 } };
            const promptResult = await callGeminiApi(GEMINI_TEXT_API_URL, promptPayload);
            const imagePrompt = promptResult.candidates[0].content.parts[0].text.trim();

            const imagePayload = {
                 contents: [{ parts: [{ text: `${imagePrompt} (9:16 aspect ratio, vertical, cinematic, photorealistic)` }] }],
                 generationConfig: { responseModalities: ['TEXT', 'IMAGE'] }
            };
            const imageResult = await callGeminiApi(GEMINI_IMAGE_API_URL, imagePayload);
            const imagePart = imageResult.candidates[0].content.parts.find(p => p.inlineData && p.inlineData.mimeType.startsWith("image/"));
            if (!imagePart) { throw new Error(`API n√£o retornou uma imagem para o prompt: "${imagePrompt}"`); }
            
            const imageBase64 = imagePart.inlineData.data;
            imageUrls.push(`data:image/png;base64,${imageBase64}`);
        }
        return imageUrls;
    }

    async function iniciarAnimadorDeLegendas(renderer, transcriptionData) {
    try {
        if (!transcriptionData || (!transcriptionData.words && !transcriptionData.segments)) {
            throw new Error("Dados de transcri√ß√£o inv√°lidos.");
        }
        
        const subtitleAnimator = new WordSubtitleAnimator();
        subtitleAnimator.init(renderer);
        
        if (transcriptionData.words && transcriptionData.words.length > 0) {
            subtitleAnimator.setTimeline(transcriptionData);
        } else if (transcriptionData.segments) {
            subtitleAnimator.setTimeline(transcriptionData.segments);
        }
        
        renderer.subtitleAnimator = subtitleAnimator;
        
        // Inicia imediatamente com o elemento de √°udio do renderer
        subtitleAnimator.startAnimation(renderer.audioElement);
        
        console.log('‚úÖ Sistema de legendas iniciado (timing real)');
        
    } catch (error) {
        console.error("Erro no m√≥dulo de legendas:", error);
    }
}

    function formatSrtTime(seconds) {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = Math.floor(seconds % 60).toString().padStart(2, '0');
        const ms = Math.round((seconds - Math.floor(seconds)) * 1000).toString().padStart(3, '0');
        return `${h}:${m}:${s},${ms}`;
    }


window.generateVideoForPuppeteer = async function() {
    try {
        const scriptText = 'Ol√°, tudo bem? Como est√°? Bom dia!';
        const audioBlob = await generateAudio(scriptText);
        const transcriptionResult = await transcribeAudio(audioBlob);
        const timedChunks = groupTranscriptionIntoTimedChunks(transcriptionResult.segments);
        const imageDataUrls = await generateImagesForTimedChunks(timedChunks, timedChunks.length);

        const renderer = new CapCutStyleGenerator('pixi-container', 'generation-status');
        await renderer.init();

        const audioUrl = URL.createObjectURL(audioBlob);
        await renderer.loadAssets(imageDataUrls, audioUrl);

        const srtContent = timedChunks.map((chunk, i) => {
            return `${i + 1}\n${formatSrtTime(chunk.start)} --> ${formatSrtTime(chunk.end)}\n${chunk.text}`;
        }).join('\n\n');
        
        renderer.parseSRT(srtContent);
        await iniciarAnimadorDeLegendas(renderer, transcriptionResult);

        // Capturar v√≠deo e √°udio
        return await new Promise((resolve) => {
            renderer.exportVideo(async (finalVideoUrl) => {
                if(finalVideoUrl) {
                    try {
                        const videoResponse = await fetch(finalVideoUrl);
                        const videoBuffer = await videoResponse.arrayBuffer();
                        
                        const audioResponse = await fetch(audioUrl);
                        const audioBuffer = await audioResponse.arrayBuffer();
                        
                        resolve({
                            video: Array.from(new Uint8Array(videoBuffer)),
                            audio: Array.from(new Uint8Array(audioBuffer)),
                            duration: renderer.audioElement.duration,
                            success: true
                        });
                    } catch (error) {
                        resolve({ success: false, error: error.message });
                    }
                } else {
                    resolve({ success: false, error: "V√≠deo n√£o gerado" });
                }
            });
        });

    } catch (error) {
        return { success: false, error: error.message };
    }
};

// Sinalizar que a p√°gina est√° pronta
window.pageReady = true;

    
  </script>
</body>
</html>
